#!/usr/bin/env python3
# beryllium ipa generator
# builds standalone .ipa files that wrap a single website into a native ios app.
# requires macos with xcode command line tools and xcodegen installed.

import argparse
import json
import os
import plistlib
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

SCRIPT_DIR = Path(__file__).parent.resolve()


def log(msg):
    print(f"[beryllium] {msg}")


def error(msg):
    print(f"[beryllium] error: {msg}", file=sys.stderr)
    sys.exit(1)


def check_requirements():
    """make sure we're on macos with xcode tools and xcodegen available."""
    if sys.platform != "darwin":
        error("ipa generation requires macos with xcode installed.")
    if shutil.which("xcodebuild") is None:
        error("xcodebuild not found. install xcode command line tools: xcode-select --install")
    if shutil.which("xcodegen") is None:
        error("xcodegen not found. install it with: brew install xcodegen")


def parse_config(config_path):
    """load a site configuration json file."""
    with open(config_path, "r") as f:
        config = json.load(f)

    required = ["name", "url"]
    for key in required:
        if key not in config:
            error(f"config missing required key: {key}")

    # fill in defaults for optional fields
    defaults = {
        "bundle_id": f"com.beryllium.wrap.{config['name'].lower().replace(' ', '-')}",
        "orientation": "automatic",
        "javascript": True,
        "stikjit": False,
        "inline_media": True,
        "fullscreen": False,
        "user_agent": "",
        "icon_path": None,
        "version": "1.0",
        "deployment_target": "16.0",
    }
    for key, default in defaults.items():
        config.setdefault(key, default)

    return config


def generate_swift_source(config):
    """generate the main swift source for the stub app."""
    # escape strings for swift
    name = config["name"].replace("\\", "\\\\").replace('"', '\\"')
    url = config["url"].replace("\\", "\\\\").replace('"', '\\"')
    user_agent = config["user_agent"].replace("\\", "\\\\").replace('"', '\\"')

    orientation_mask = {
        "portrait": ".portrait",
        "landscape": ".landscape",
        "automatic": ".all",
    }.get(config["orientation"], ".all")

    return f'''// auto-generated by beryllium ipa generator
// wraps: {url}

import SwiftUI
import WebKit

@main
struct WrappedApp: App {{
    var body: some Scene {{
        WindowGroup {{
            WrappedWebView()
                .ignoresSafeArea({".all" if config["fullscreen"] else ".init()"})
                .statusBarHidden({str(config["fullscreen"]).lower()})
                .onAppear {{ applyOrientation() }}
        }}
    }}

    // lock orientation on launch
    private func applyOrientation() {{
        guard let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene else {{ return }}
        let prefs = UIWindowScene.GeometryPreferences.iOS(interfaceOrientations: {orientation_mask})
        scene.requestGeometryUpdate(prefs) {{ _ in }}
    }}
}}

struct WrappedWebView: UIViewRepresentable {{
    func makeUIView(context: Context) -> WKWebView {{
        let config = WKWebViewConfiguration()
        let prefs = WKWebpagePreferences()
        prefs.allowsContentJavaScript = {str(config["javascript"]).lower()}
        config.defaultWebpagePreferences = prefs
        config.allowsInlineMediaPlayback = {str(config["inline_media"]).lower()}
        config.mediaTypesRequiringUserActionForPlayback = []

        let webView = WKWebView(frame: .zero, configuration: config)
        webView.allowsBackForwardNavigationGestures = true

        let userAgent = "{user_agent}"
        if !userAgent.isEmpty {{
            webView.customUserAgent = userAgent
        }}

        if let url = URL(string: "{url}") {{
            webView.load(URLRequest(url: url))
        }}

        return webView
    }}

    func updateUIView(_ uiView: WKWebView, context: Context) {{}}
}}
'''


def generate_info_plist(config):
    """generate the info.plist for the stub app."""
    orientations = {
        "portrait": ["UIInterfaceOrientationPortrait"],
        "landscape": [
            "UIInterfaceOrientationLandscapeLeft",
            "UIInterfaceOrientationLandscapeRight",
        ],
        "automatic": [
            "UIInterfaceOrientationPortrait",
            "UIInterfaceOrientationLandscapeLeft",
            "UIInterfaceOrientationLandscapeRight",
            "UIInterfaceOrientationPortraitUpsideDown",
        ],
    }.get(config["orientation"], ["UIInterfaceOrientationPortrait"])

    plist = {
        "CFBundleDevelopmentRegion": "en",
        "CFBundleDisplayName": config["name"],
        "CFBundleExecutable": "$(EXECUTABLE_NAME)",
        "CFBundleIdentifier": config["bundle_id"],
        "CFBundleInfoDictionaryVersion": "6.0",
        "CFBundleName": "$(PRODUCT_NAME)",
        "CFBundlePackageType": "APPL",
        "CFBundleShortVersionString": config["version"],
        "CFBundleVersion": "1",
        "LSRequiresIPhoneOS": True,
        "UIApplicationSceneManifest": {
            "UIApplicationSupportsMultipleScenes": False,
            "UISceneConfigurations": {},
        },
        "UILaunchScreen": {},
        "UISupportedInterfaceOrientations": orientations,
        "UISupportedInterfaceOrientations~ipad": orientations,
        "NSAppTransportSecurity": {"NSAllowsArbitraryLoads": True},
    }

    # handle stikjit url scheme
    if config["stikjit"]:
        plist["LSApplicationQueriesSchemes"] = ["stikjit"]

    return plist


def generate_xcodegen_spec(config):
    """generate a project.yml for xcodegen."""
    # yaml doesn't need a library for this simple structure
    return f'''name: BerylliumStub
options:
  bundleIdPrefix: com.beryllium
  deploymentTarget:
    iOS: "{config["deployment_target"]}"
targets:
  BerylliumStub:
    type: application
    platform: iOS
    sources:
      - path: BerylliumStub
    settings:
      base:
        PRODUCT_BUNDLE_IDENTIFIER: "{config["bundle_id"]}"
        INFOPLIST_FILE: BerylliumStub/Info.plist
        GENERATE_INFOPLIST_FILE: true
        ASSETCATALOG_COMPILER_APPICON_NAME: AppIcon
        CODE_SIGN_STYLE: Automatic
        CURRENT_PROJECT_VERSION: 1
        MARKETING_VERSION: "{config["version"]}"
        INFOPLIST_KEY_CFBundleDisplayName: "{config["name"]}"
        INFOPLIST_KEY_UIApplicationSceneManifest_Generation: true
        INFOPLIST_KEY_UILaunchScreen_Generation: true
        SWIFT_VERSION: "5.0"
        TARGETED_DEVICE_FAMILY: "1,2"
'''


def setup_app_icon(config, assets_dir):
    """copy a custom icon into the asset catalog if provided."""
    icon_dir = assets_dir / "AppIcon.appiconset"
    icon_dir.mkdir(parents=True, exist_ok=True)

    if config["icon_path"] and Path(config["icon_path"]).exists():
        icon_src = Path(config["icon_path"])
        icon_dst = icon_dir / "AppIcon.png"
        shutil.copy2(icon_src, icon_dst)
        contents = {
            "images": [
                {
                    "filename": "AppIcon.png",
                    "idiom": "universal",
                    "platform": "ios",
                    "size": "1024x1024",
                }
            ],
            "info": {"author": "xcode", "version": 1},
        }
    else:
        contents = {
            "images": [
                {"idiom": "universal", "platform": "ios", "size": "1024x1024"}
            ],
            "info": {"author": "xcode", "version": 1},
        }

    with open(icon_dir / "Contents.json", "w") as f:
        json.dump(contents, f, indent=2)

    # root asset catalog contents
    with open(assets_dir / "Contents.json", "w") as f:
        json.dump({"info": {"author": "xcode", "version": 1}}, f, indent=2)


def build_ipa(project_dir, output_path, config):
    """run xcodebuild to archive and package an ipa."""
    scheme = "BerylliumStub"
    archive_path = project_dir / "build" / f"{scheme}.xcarchive"

    log("building archive...")
    archive_cmd = [
        "xcodebuild",
        "archive",
        "-project", str(project_dir / "BerylliumStub.xcodeproj"),
        "-scheme", scheme,
        "-archivePath", str(archive_path),
        "-sdk", "iphoneos",
        "-configuration", "Release",
        "-destination", "generic/platform=iOS",
        "CODE_SIGN_IDENTITY=",
        "CODE_SIGNING_REQUIRED=NO",
        "CODE_SIGNING_ALLOWED=NO",
        "SKIP_INSTALL=NO",
        "BUILD_LIBRARY_FOR_DISTRIBUTION=YES",
    ]

    result = subprocess.run(archive_cmd, capture_output=True, text=True)
    if result.returncode != 0:
        log("xcodebuild archive output:")
        print(result.stdout[-3000:] if len(result.stdout) > 3000 else result.stdout)
        print(result.stderr[-3000:] if len(result.stderr) > 3000 else result.stderr)
        error("archive failed. check the output above for details.")

    # manually package the .app into an ipa (no export needed for unsigned)
    log("packaging ipa...")
    manual_ipa(archive_path, output_path)


def manual_ipa(archive_path, output_path):
    """manually create an ipa from an xcarchive by zipping the payload."""
    app_dir = archive_path / "Products" / "Applications"
    if not app_dir.exists():
        error("no .app found in archive.")

    apps = list(app_dir.glob("*.app"))
    if not apps:
        error("no .app bundle found in archive products.")

    with tempfile.TemporaryDirectory() as tmp:
        payload_dir = Path(tmp) / "Payload"
        payload_dir.mkdir()
        shutil.copytree(str(apps[0]), str(payload_dir / apps[0].name))

        # create the ipa (it's just a zip file)
        ipa_tmp = Path(tmp) / "output.ipa"
        shutil.make_archive(str(ipa_tmp).replace(".ipa", ""), "zip", tmp, "Payload")
        shutil.move(str(ipa_tmp).replace(".ipa", ".zip"), str(output_path))

    log(f"ipa saved to: {output_path}")


def generate(config, output_path):
    """orchestrate the full ipa generation process."""
    with tempfile.TemporaryDirectory(prefix="beryllium-") as tmp:
        project_dir = Path(tmp)
        source_dir = project_dir / "BerylliumStub"
        assets_dir = source_dir / "Assets.xcassets"

        source_dir.mkdir()
        assets_dir.mkdir(parents=True)

        # write swift source
        swift_source = generate_swift_source(config)
        with open(source_dir / "WrappedApp.swift", "w") as f:
            f.write(swift_source)

        # write info.plist
        info_plist = generate_info_plist(config)
        with open(source_dir / "Info.plist", "wb") as f:
            plistlib.dump(info_plist, f)

        # write xcodegen project spec
        spec = generate_xcodegen_spec(config)
        spec_path = project_dir / "project.yml"
        with open(spec_path, "w") as f:
            f.write(spec)

        # setup app icon
        setup_app_icon(config, assets_dir)

        # run xcodegen to create the .xcodeproj
        log("generating xcode project with xcodegen...")
        result = subprocess.run(
            ["xcodegen", "generate", "--spec", str(spec_path)],
            capture_output=True,
            text=True,
            cwd=str(project_dir),
        )
        if result.returncode != 0:
            log("xcodegen output:")
            print(result.stderr)
            error("xcodegen failed to generate the project.")

        log("xcode project generated successfully")

        # build
        build_ipa(project_dir, Path(output_path), config)


def main():
    parser = argparse.ArgumentParser(
        description="beryllium ipa generator - wrap websites into standalone ios apps",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
examples:
  # generate from a config file
  %(prog)s --config site.json --output MyApp.ipa

  # generate with inline options
  %(prog)s --name "my app" --url "https://example.com" --output MyApp.ipa

  # with custom icon and forced landscape
  %(prog)s --name "game" --url "https://game.io" --icon icon.png --orientation landscape --output Game.ipa

config file format (json):
  {
    "name": "my app",
    "url": "https://example.com",
    "bundle_id": "com.example.myapp",
    "orientation": "portrait",
    "javascript": true,
    "stikjit": false,
    "inline_media": true,
    "fullscreen": false,
    "user_agent": "",
    "icon_path": "/path/to/icon.png",
    "version": "1.0"
  }
        """,
    )

    parser.add_argument("--config", "-c", help="path to a json config file")
    parser.add_argument("--name", "-n", help="app display name")
    parser.add_argument("--url", "-u", help="website url to wrap")
    parser.add_argument("--output", "-o", required=True, help="output .ipa file path")
    parser.add_argument("--bundle-id", help="custom bundle identifier")
    parser.add_argument("--icon", help="path to a 1024x1024 png icon")
    parser.add_argument(
        "--orientation",
        choices=["automatic", "portrait", "landscape"],
        default="automatic",
        help="force a specific orientation (default: automatic)",
    )
    parser.add_argument("--no-javascript", action="store_true", help="disable javascript")
    parser.add_argument("--stikjit", action="store_true", help="enable stikjit support")
    parser.add_argument("--fullscreen", action="store_true", help="enable full screen mode")
    parser.add_argument("--user-agent", default="", help="custom user agent string")
    parser.add_argument("--version", default="1.0", help="app version string")

    args = parser.parse_args()
    check_requirements()

    if args.config:
        config = parse_config(args.config)
    elif args.name and args.url:
        config = {
            "name": args.name,
            "url": args.url,
            "bundle_id": args.bundle_id
            or f"com.beryllium.wrap.{args.name.lower().replace(' ', '-')}",
            "orientation": args.orientation,
            "javascript": not args.no_javascript,
            "stikjit": args.stikjit,
            "inline_media": True,
            "fullscreen": args.fullscreen,
            "user_agent": args.user_agent,
            "icon_path": args.icon,
            "version": args.version,
            "deployment_target": "16.0",
        }
    else:
        error("provide either --config or both --name and --url")

    log(f"generating ipa for: {config['name']} ({config['url']})")
    generate(config, args.output)
    log("done!")


if __name__ == "__main__":
    main()
