#!/usr/bin/env python3
# beryllium ipa generator
# builds standalone .ipa files that wrap a single website into a native ios app.
# requires macos with xcode command line tools installed.

import argparse
import json
import os
import plistlib
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

SCRIPT_DIR = Path(__file__).parent.resolve()
TEMPLATE_DIR = SCRIPT_DIR / "templates"


def log(msg):
    print(f"[beryllium] {msg}")


def error(msg):
    print(f"[beryllium] error: {msg}", file=sys.stderr)
    sys.exit(1)


def check_requirements():
    """make sure we're on macos with xcode tools available."""
    if sys.platform != "darwin":
        error("ipa generation requires macos with xcode installed.")
    if shutil.which("xcodebuild") is None:
        error("xcodebuild not found. install xcode command line tools: xcode-select --install")


def parse_config(config_path):
    """load a site configuration json file."""
    with open(config_path, "r") as f:
        config = json.load(f)

    required = ["name", "url"]
    for key in required:
        if key not in config:
            error(f"config missing required key: {key}")

    # fill in defaults for optional fields
    defaults = {
        "bundle_id": f"com.beryllium.wrap.{config['name'].lower().replace(' ', '-')}",
        "orientation": "automatic",
        "javascript": True,
        "stikjit": False,
        "inline_media": True,
        "fullscreen": False,
        "user_agent": "",
        "icon_path": None,
        "version": "1.0",
        "deployment_target": "16.0",
    }
    for key, default in defaults.items():
        config.setdefault(key, default)

    return config


def generate_swift_source(config):
    """generate the main swift source for the stub app."""
    # escape strings for swift
    name = config["name"].replace("\\", "\\\\").replace('"', '\\"')
    url = config["url"].replace("\\", "\\\\").replace('"', '\\"')
    user_agent = config["user_agent"].replace("\\", "\\\\").replace('"', '\\"')

    orientation_mask = {
        "portrait": ".portrait",
        "landscape": ".landscape",
        "automatic": ".all",
    }.get(config["orientation"], ".all")

    return f'''// auto-generated by beryllium ipa generator
// wraps: {url}

import SwiftUI
import WebKit

@main
struct WrappedApp: App {{
    var body: some Scene {{
        WindowGroup {{
            WrappedWebView()
                .ignoresSafeArea({".all" if config["fullscreen"] else ".init()"})
                .statusBarHidden({str(config["fullscreen"]).lower()})
                .onAppear {{ applyOrientation() }}
        }}
    }}

    // lock orientation on launch
    private func applyOrientation() {{
        guard let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene else {{ return }}
        let prefs = UIWindowScene.GeometryPreferences.iOS(interfaceOrientations: {orientation_mask})
        scene.requestGeometryUpdate(prefs) {{ _ in }}
    }}
}}

struct WrappedWebView: UIViewRepresentable {{
    func makeUIView(context: Context) -> WKWebView {{
        let config = WKWebViewConfiguration()
        let prefs = WKWebpagePreferences()
        prefs.allowsContentJavaScript = {str(config["javascript"]).lower()}
        config.defaultWebpagePreferences = prefs
        config.allowsInlineMediaPlayback = {str(config["inline_media"]).lower()}
        config.mediaTypesRequiringUserActionForPlayback = []

        let webView = WKWebView(frame: .zero, configuration: config)
        webView.allowsBackForwardNavigationGestures = true

        let userAgent = "{user_agent}"
        if !userAgent.isEmpty {{
            webView.customUserAgent = userAgent
        }}

        if let url = URL(string: "{url}") {{
            webView.load(URLRequest(url: url))
        }}

        return webView
    }}

    func updateUIView(_ uiView: WKWebView, context: Context) {{}}
}}
'''


def generate_info_plist(config):
    """generate the info.plist for the stub app."""
    orientations = {
        "portrait": ["UIInterfaceOrientationPortrait"],
        "landscape": [
            "UIInterfaceOrientationLandscapeLeft",
            "UIInterfaceOrientationLandscapeRight",
        ],
        "automatic": [
            "UIInterfaceOrientationPortrait",
            "UIInterfaceOrientationLandscapeLeft",
            "UIInterfaceOrientationLandscapeRight",
            "UIInterfaceOrientationPortraitUpsideDown",
        ],
    }.get(config["orientation"], ["UIInterfaceOrientationPortrait"])

    plist = {
        "CFBundleDevelopmentRegion": "en",
        "CFBundleDisplayName": config["name"],
        "CFBundleExecutable": "$(EXECUTABLE_NAME)",
        "CFBundleIdentifier": config["bundle_id"],
        "CFBundleInfoDictionaryVersion": "6.0",
        "CFBundleName": "$(PRODUCT_NAME)",
        "CFBundlePackageType": "APPL",
        "CFBundleShortVersionString": config["version"],
        "CFBundleVersion": "1",
        "LSRequiresIPhoneOS": True,
        "UIApplicationSceneManifest": {
            "UIApplicationSupportsMultipleScenes": False,
            "UISceneConfigurations": {},
        },
        "UILaunchScreen": {},
        "UISupportedInterfaceOrientations": orientations,
        "UISupportedInterfaceOrientations~ipad": orientations,
        "NSAppTransportSecurity": {"NSAllowsArbitraryLoads": True},
    }

    # handle stikjit url scheme
    if config["stikjit"]:
        plist["LSApplicationQueriesSchemes"] = ["stikjit"]

    return plist


def generate_xcodeproj(config, project_dir):
    """generate a minimal xcode project for the stub app."""
    # we use a simplified pbxproj that xcodebuild can process
    pbxproj_content = '''// !$*UTF8*$!
{
    archiveVersion = 1;
    classes = {};
    objectVersion = 56;
    objects = {
        B10000001 /* WrappedApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = B20000001;};
        B10000002 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = B20000002;};
        B20000001 /* WrappedApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WrappedApp.swift; sourceTree = "<group>";};
        B20000002 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>";};
        B20000003 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>";};
        B30000001 /* BerylliumStub.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = BerylliumStub.app; sourceTree = BUILT_PRODUCTS_DIR;};
        B40000001 /* Frameworks */ = {isa = PBXFrameworksBuildPhase; buildActionMask = 2147483647; files = (); runOnlyForDeploymentPostprocessing = 0;};
        B50000001 = {isa = PBXGroup; children = (B50000002, B50000003); sourceTree = "<group>";};
        B50000002 /* BerylliumStub */ = {isa = PBXGroup; children = (B20000001, B20000002, B20000003); path = BerylliumStub; sourceTree = "<group>";};
        B50000003 /* Products */ = {isa = PBXGroup; children = (B30000001); name = Products; sourceTree = "<group>";};
        B60000001 /* BerylliumStub */ = {
            isa = PBXNativeTarget;
            buildConfigurationList = B80000002;
            buildPhases = (B70000001, B40000001, B70000002);
            buildRules = ();
            dependencies = ();
            name = BerylliumStub;
            productName = BerylliumStub;
            productReference = B30000001;
            productType = "com.apple.product-type.application";
        };
        B90000001 /* Project object */ = {
            isa = PBXProject;
            attributes = {
                BuildIndependentTargetsInParallel = 1;
                LastSwiftUpdateCheck = 1500;
                LastUpgradeCheck = 1500;
                TargetAttributes = { B60000001 = { CreatedOnToolsVersion = 15.0; }; };
            };
            buildConfigurationList = B80000001;
            compatibilityVersion = "Xcode 14.0";
            developmentRegion = en;
            hasScannedForEncodings = 0;
            knownRegions = (en, Base);
            mainGroup = B50000001;
            productRefGroup = B50000003;
            projectDirPath = "";
            projectRoot = "";
            targets = (B60000001);
        };
        B70000001 /* Sources */ = {isa = PBXSourcesBuildPhase; buildActionMask = 2147483647; files = (B10000001); runOnlyForDeploymentPostprocessing = 0;};
        B70000002 /* Resources */ = {isa = PBXResourcesBuildPhase; buildActionMask = 2147483647; files = (B10000002); runOnlyForDeploymentPostprocessing = 0;};
        B80000001 /* Build configuration list for PBXProject */ = {
            isa = XCConfigurationList;
            buildConfigurations = (B80000011, B80000012);
            defaultConfigurationIsVisible = 0;
            defaultConfigurationName = Release;
        };
        B80000002 /* Build configuration list for PBXNativeTarget */ = {
            isa = XCConfigurationList;
            buildConfigurations = (B80000021, B80000022);
            defaultConfigurationIsVisible = 0;
            defaultConfigurationName = Release;
        };
        B80000011 /* Debug */ = {
            isa = XCBuildConfiguration;
            buildSettings = {
                ALWAYS_SEARCH_USER_PATHS = NO;
                CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
                CLANG_ENABLE_MODULES = YES;
                CLANG_ENABLE_OBJC_ARC = YES;
                COPY_PHASE_STRIP = NO;
                DEBUG_INFORMATION_FORMAT = dwarf;
                ENABLE_TESTABILITY = YES;
                GCC_DYNAMIC_NO_PIC = NO;
                GCC_OPTIMIZATION_LEVEL = 0;
                IPHONEOS_DEPLOYMENT_TARGET = ''' + config["deployment_target"] + ''';
                MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
                ONLY_ACTIVE_ARCH = YES;
                SDKROOT = iphoneos;
                SWIFT_ACTIVE_COMPILATION_CONDITIONS = "$(inherited) DEBUG";
                SWIFT_OPTIMIZATION_LEVEL = "-Onone";
            };
            name = Debug;
        };
        B80000012 /* Release */ = {
            isa = XCBuildConfiguration;
            buildSettings = {
                ALWAYS_SEARCH_USER_PATHS = NO;
                CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
                CLANG_ENABLE_MODULES = YES;
                CLANG_ENABLE_OBJC_ARC = YES;
                COPY_PHASE_STRIP = NO;
                DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
                ENABLE_NS_ASSERTIONS = NO;
                IPHONEOS_DEPLOYMENT_TARGET = ''' + config["deployment_target"] + ''';
                SDKROOT = iphoneos;
                SWIFT_COMPILATION_MODE = wholemodule;
                VALIDATE_PRODUCT = YES;
            };
            name = Release;
        };
        B80000021 /* Debug */ = {
            isa = XCBuildConfiguration;
            buildSettings = {
                ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
                CODE_SIGN_STYLE = Automatic;
                CURRENT_PROJECT_VERSION = 1;
                GENERATE_INFOPLIST_FILE = YES;
                INFOPLIST_FILE = BerylliumStub/Info.plist;
                INFOPLIST_KEY_CFBundleDisplayName = "''' + config["name"].replace('"', '\\"') + '''";
                INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
                INFOPLIST_KEY_UILaunchScreen_Generation = YES;
                LD_RUNPATH_SEARCH_PATHS = ("$(inherited)", "@executable_path/Frameworks");
                MARKETING_VERSION = ''' + config["version"] + ''';
                PRODUCT_BUNDLE_IDENTIFIER = "''' + config["bundle_id"] + '''";
                PRODUCT_NAME = "$(TARGET_NAME)";
                SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
                SWIFT_EMIT_LOC_STRINGS = YES;
                SWIFT_VERSION = 5.0;
                TARGETED_DEVICE_FAMILY = "1,2";
            };
            name = Debug;
        };
        B80000022 /* Release */ = {
            isa = XCBuildConfiguration;
            buildSettings = {
                ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
                CODE_SIGN_STYLE = Automatic;
                CURRENT_PROJECT_VERSION = 1;
                GENERATE_INFOPLIST_FILE = YES;
                INFOPLIST_FILE = BerylliumStub/Info.plist;
                INFOPLIST_KEY_CFBundleDisplayName = "''' + config["name"].replace('"', '\\"') + '''";
                INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
                INFOPLIST_KEY_UILaunchScreen_Generation = YES;
                LD_RUNPATH_SEARCH_PATHS = ("$(inherited)", "@executable_path/Frameworks");
                MARKETING_VERSION = ''' + config["version"] + ''';
                PRODUCT_BUNDLE_IDENTIFIER = "''' + config["bundle_id"] + '''";
                PRODUCT_NAME = "$(TARGET_NAME)";
                SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
                SWIFT_EMIT_LOC_STRINGS = YES;
                SWIFT_VERSION = 5.0;
                TARGETED_DEVICE_FAMILY = "1,2";
            };
            name = Release;
        };
    };
    rootObject = B90000001;
}
'''
    return pbxproj_content


def setup_app_icon(config, assets_dir):
    """copy a custom icon into the asset catalog if provided."""
    icon_dir = assets_dir / "AppIcon.appiconset"
    icon_dir.mkdir(parents=True, exist_ok=True)

    if config["icon_path"] and Path(config["icon_path"]).exists():
        icon_src = Path(config["icon_path"])
        icon_dst = icon_dir / "AppIcon.png"
        shutil.copy2(icon_src, icon_dst)
        contents = {
            "images": [
                {
                    "filename": "AppIcon.png",
                    "idiom": "universal",
                    "platform": "ios",
                    "size": "1024x1024",
                }
            ],
            "info": {"author": "xcode", "version": 1},
        }
    else:
        contents = {
            "images": [
                {"idiom": "universal", "platform": "ios", "size": "1024x1024"}
            ],
            "info": {"author": "xcode", "version": 1},
        }

    with open(icon_dir / "Contents.json", "w") as f:
        json.dump(contents, f, indent=2)

    # root asset catalog contents
    with open(assets_dir / "Contents.json", "w") as f:
        json.dump({"info": {"author": "xcode", "version": 1}}, f, indent=2)


def build_ipa(project_dir, output_path, config):
    """run xcodebuild to archive and export an ipa."""
    scheme = "BerylliumStub"
    archive_path = project_dir / "build" / f"{scheme}.xcarchive"

    log("building archive...")
    archive_cmd = [
        "xcodebuild",
        "archive",
        "-project", str(project_dir / "BerylliumStub.xcodeproj"),
        "-scheme", scheme,
        "-archivePath", str(archive_path),
        "-sdk", "iphoneos",
        "-configuration", "Release",
        "SKIP_INSTALL=NO",
        "BUILD_LIBRARY_FOR_DISTRIBUTION=YES",
    ]

    result = subprocess.run(archive_cmd, capture_output=True, text=True)
    if result.returncode != 0:
        log("xcodebuild archive output:")
        print(result.stderr)
        error("archive failed. make sure xcode and a valid signing identity are configured.")

    log("exporting ipa...")
    export_dir = project_dir / "build" / "export"

    # create export options plist
    export_options = {
        "method": "development",
        "compileBitcode": False,
        "stripSwiftSymbols": True,
        "thinning": "<none>",
    }
    export_plist_path = project_dir / "ExportOptions.plist"
    with open(export_plist_path, "wb") as f:
        plistlib.dump(export_options, f)

    export_cmd = [
        "xcodebuild",
        "-exportArchive",
        "-archivePath", str(archive_path),
        "-exportOptionsPlist", str(export_plist_path),
        "-exportPath", str(export_dir),
    ]

    result = subprocess.run(export_cmd, capture_output=True, text=True)
    if result.returncode != 0:
        log("xcodebuild export output:")
        print(result.stderr)

        # fallback: manually package the .app into an ipa
        log("falling back to manual ipa packaging...")
        manual_ipa(archive_path, output_path)
        return

    # find the generated ipa and move it to the output path
    for f in export_dir.iterdir():
        if f.suffix == ".ipa":
            shutil.move(str(f), str(output_path))
            log(f"ipa saved to: {output_path}")
            return

    error("export succeeded but no .ipa was found in the output.")


def manual_ipa(archive_path, output_path):
    """manually create an ipa from an xcarchive by zipping the payload."""
    app_dir = archive_path / "Products" / "Applications"
    if not app_dir.exists():
        error("no .app found in archive.")

    apps = list(app_dir.glob("*.app"))
    if not apps:
        error("no .app bundle found in archive products.")

    with tempfile.TemporaryDirectory() as tmp:
        payload_dir = Path(tmp) / "Payload"
        payload_dir.mkdir()
        shutil.copytree(str(apps[0]), str(payload_dir / apps[0].name))

        # create the ipa (it's just a zip file)
        ipa_tmp = Path(tmp) / "output.ipa"
        shutil.make_archive(str(ipa_tmp).replace(".ipa", ""), "zip", tmp, "Payload")
        shutil.move(str(ipa_tmp).replace(".ipa", ".zip"), str(output_path))

    log(f"ipa saved to: {output_path}")


def generate(config, output_path):
    """orchestrate the full ipa generation process."""
    with tempfile.TemporaryDirectory(prefix="beryllium-") as tmp:
        project_dir = Path(tmp)
        source_dir = project_dir / "BerylliumStub"
        xcodeproj_dir = project_dir / "BerylliumStub.xcodeproj"
        assets_dir = source_dir / "Assets.xcassets"

        source_dir.mkdir()
        xcodeproj_dir.mkdir()
        assets_dir.mkdir(parents=True)

        # write swift source
        swift_source = generate_swift_source(config)
        with open(source_dir / "WrappedApp.swift", "w") as f:
            f.write(swift_source)

        # write info.plist
        info_plist = generate_info_plist(config)
        with open(source_dir / "Info.plist", "wb") as f:
            plistlib.dump(info_plist, f)

        # write xcode project
        pbxproj = generate_xcodeproj(config, project_dir)
        with open(xcodeproj_dir / "project.pbxproj", "w") as f:
            f.write(pbxproj)

        # write xcscheme so xcodebuild can find it
        schemes_dir = xcodeproj_dir / "xcshareddata" / "xcschemes"
        schemes_dir.mkdir(parents=True)
        write_scheme(schemes_dir / "BerylliumStub.xcscheme")

        # setup app icon
        setup_app_icon(config, assets_dir)

        # build
        build_ipa(project_dir, Path(output_path), config)


def write_scheme(path):
    """write a minimal xcscheme file for xcodebuild."""
    scheme_xml = '''<?xml version="1.0" encoding="UTF-8"?>
<Scheme LastUpgradeVersion="1500" version="1.7">
   <BuildAction buildImplicitDependencies="YES" parallelizeBuildables="YES">
      <BuildActionEntries>
         <BuildActionEntry buildForRunning="YES" buildForTesting="YES" buildForProfiling="YES" buildForArchiving="YES" buildForAnalyzing="YES">
            <BuildableReference
               BuildableIdentifier="primary"
               BlueprintIdentifier="B60000001"
               BuildableName="BerylliumStub.app"
               BlueprintName="BerylliumStub"
               ReferencedContainer="container:BerylliumStub.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <LaunchAction selectedDebuggerIdentifier="Xcode.DebuggerFoundation.Debugger.LLDB" selectedLauncherIdentifier="Xcode.DebuggerFoundation.Launcher.LLDB" launchStyle="0" useCustomWorkingDirectory="NO" ignoresPersistentStateOnLaunch="NO" debugDocumentVersioning="YES" debugServiceExtension="internal" allowLocationSimulation="YES">
      <BuildableProductRunnable runnableDebuggingMode="0">
         <BuildableReference
            BuildableIdentifier="primary"
            BlueprintIdentifier="B60000001"
            BuildableName="BerylliumStub.app"
            BlueprintName="BerylliumStub"
            ReferencedContainer="container:BerylliumStub.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ArchiveAction buildConfiguration="Release" revealArchiveInOrganizer="YES">
   </ArchiveAction>
</Scheme>
'''
    with open(path, "w") as f:
        f.write(scheme_xml)


def main():
    parser = argparse.ArgumentParser(
        description="beryllium ipa generator - wrap websites into standalone ios apps",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
examples:
  # generate from a config file
  %(prog)s --config site.json --output MyApp.ipa

  # generate with inline options
  %(prog)s --name "my app" --url "https://example.com" --output MyApp.ipa

  # with custom icon and forced landscape
  %(prog)s --name "game" --url "https://game.io" --icon icon.png --orientation landscape --output Game.ipa

config file format (json):
  {
    "name": "my app",
    "url": "https://example.com",
    "bundle_id": "com.example.myapp",
    "orientation": "portrait",
    "javascript": true,
    "stikjit": false,
    "inline_media": true,
    "fullscreen": false,
    "user_agent": "",
    "icon_path": "/path/to/icon.png",
    "version": "1.0"
  }
        """,
    )

    parser.add_argument("--config", "-c", help="path to a json config file")
    parser.add_argument("--name", "-n", help="app display name")
    parser.add_argument("--url", "-u", help="website url to wrap")
    parser.add_argument("--output", "-o", required=True, help="output .ipa file path")
    parser.add_argument("--bundle-id", help="custom bundle identifier")
    parser.add_argument("--icon", help="path to a 1024x1024 png icon")
    parser.add_argument(
        "--orientation",
        choices=["automatic", "portrait", "landscape"],
        default="automatic",
        help="force a specific orientation (default: automatic)",
    )
    parser.add_argument("--no-javascript", action="store_true", help="disable javascript")
    parser.add_argument("--stikjit", action="store_true", help="enable stikjit support")
    parser.add_argument("--fullscreen", action="store_true", help="enable full screen mode")
    parser.add_argument("--user-agent", default="", help="custom user agent string")
    parser.add_argument("--version", default="1.0", help="app version string")

    args = parser.parse_args()
    check_requirements()

    if args.config:
        config = parse_config(args.config)
    elif args.name and args.url:
        config = {
            "name": args.name,
            "url": args.url,
            "bundle_id": args.bundle_id
            or f"com.beryllium.wrap.{args.name.lower().replace(' ', '-')}",
            "orientation": args.orientation,
            "javascript": not args.no_javascript,
            "stikjit": args.stikjit,
            "inline_media": True,
            "fullscreen": args.fullscreen,
            "user_agent": args.user_agent,
            "icon_path": args.icon,
            "version": args.version,
            "deployment_target": "16.0",
        }
    else:
        error("provide either --config or both --name and --url")

    log(f"generating ipa for: {config['name']} ({config['url']})")
    generate(config, args.output)
    log("done!")


if __name__ == "__main__":
    main()
